// ==UserScript==
// @name             Torn Booster Alert
// @namespace        Torn_Booster_Alerts
// @version          1.6.13
// @description      Alerts when no booster cooldown is active,
// @author           GNSC4 [268863]
// @match            https://www.torn.com/*
// @grant            GM_addStyle
// @grant            GM_info
// @require          https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js
// @icon             https://www.google.com/s2/favicons?sz=64&domain=torn.com
// @updateURL        https://github.com/gnsc4/Torn-Scripts/raw/refs/heads/master/Torn%20Booster%20Alerts/Torn_Booster_Alerts.user.js
// @downloadURL      https://github.com/gnsc4/Torn-Scripts/raw/refs/heads/master/Torn%20Booster%20Alerts/Torn_Booster_Alerts.user.js
// ==/UserScript==

(function() {
    'use strict';

    // Exit early on specific pages
    if (window.location.href.includes('sid=getInAttack') ||
        window.location.href.includes('sid=attack') ||
        window.location.href.includes('loader2.php') ||
        window.location.href.includes('sid=travel') ||
        window.location.pathname.includes('loader2.php')) {
        console.log('[BoosterAlert Script] Exiting: Detected Attack/Travel page.');
        return;
    }

    // --- Configuration ---
    let DEBUG_MODE = false; // Set true for detailed logs
    const SCRIPT_VERSION = GM_info.script.version || '1.6.12'; // Get version from metadata
    // MODIFIED: Use localStorage key
    const LOCAL_STORAGE_KEY = 'boosterAlerts_KnownCounts_v2'; // Key for storing counts persistently (_v2 avoids conflicts)
    const TAB_SWITCH_RESCAN_DELAY = 750; // ms delay after tab click before rescanning items
    const CONTAINER_WAIT_TIMEOUT = 20000; // Max time (ms) to wait for main item container structure to appear
    // --- End Configuration ---

    // --- Default Booster Colors (Based on Category) ---
    const defaultBoosterColors = {
        energy: '#4CAF50', nerve: '#F44336', happy: '#FFEB3B', statEnhancers: '#2196F3', default: '#9E9E9E'
    };
    // --- End Booster Colors ---

    // --- Booster Data ---
    const BOOSTERS = {
        energy: [ { id: 987, name: "Can of Crocozade" }, { id: 986, name: "Can of Damp Valley" }, { id: 985, name: "Can of Goose Juice" }, { id: 530, name: "Can of Munster" }, { id: 532, name: "Can of Red Cow" }, { id: 554, name: "Can of Rockstar Rudolph" }, { id: 553, name: "Can of Santa Shooters" }, { id: 533, name: "Can of Taurine Elite" }, { id: 555, name: "Can of X-MASS" }, { id: 367, name: "Feathery Hotel Coupon" } ],
        nerve: [ { id: 180, name: "Bottle of Beer" }, { id: 181, name: "Bottle of Champagne" }, { id: 638, name: "Bottle of Christmas Cocktail" }, { id: 924, name: "Bottle of Christmas Spirit" }, { id: 873, name: "Bottle of Green Stout" }, { id: 550, name: "Bottle of Kandy Kane" }, { id: 551, name: "Bottle of Minty Mayhem" }, { id: 552, name: "Bottle of Mistletoe Madness" }, { id: 984, name: "Bottle of Moonshine" }, { id: 531, name: "Bottle of Pumpkin Brew" }, { id: 294, name: "Bottle Of Sake Brew" }, { id: 541, name: "Bottle of Stinky Swamp Punch" }, { id: 426, name: "Bottle of Tequila" }, { id: 542, name: "Bottle of Wicked Witch" } ],
        happy: [ { id: 634, name: "Bag of Blood Eyeballs" }, { id: 37, name: "Bag of Bon Bons" }, { id: 527, name: "Bag of Candy Kisses" }, { id: 210, name: "Bag of Chocolate Kisses" }, { id: 529, name: "Bag of Chocolate Truffles" }, { id: 1039, name: "Bag of Humbugs" }, { id: 556, name: "Bag of Raindeer Droppings" }, { id: 587, name: "Bag of Sherbet" }, { id: 528, name: "Bag of Tootsie Rolls" }, { id: 36, name: "Big Box of Chocolate Bars" }, { id: 1028, name: "Birthday Cupcake" }, { id: 38, name: "Box of Bon Bons" }, { id: 35, name: "Box of Chocolate Bars" }, { id: 39, name: "Box of Extra Strong Mints" }, { id: 209, name: "Box of Sweet Hearts" }, { id: 1312, name: "Chocolate Egg" }, { id: 586, name: "Jawbreaker" }, { id: 310, name: "Lollipop" }, { id: 151, name: "Pixie Sticks" }, { id: 366, name: "Erotic DVD" } ],
        statEnhancers: [ { id: 329, name: "Skateboard", effect: "Speed" }, { id: 331, name: "Dumbbells", effect: "Strength" }, { id: 106, name: "Parachute", effect: "Dexterity" }, { id: 330, name: "Boxing Gloves", effect: "Defense" } ]
    };
    const allBoostersFlat = Object.values(BOOSTERS).flat();
    // --- End Booster Data ---

    // --- Global State Variables ---
    let alertElements = null;
    let useFactionBoosters = localStorage.getItem('useFactionBoosters') === 'true';
    let coopObserver = null;
    let coopAdjustInterval = null;
    let cooldownCheckInterval = null;
    let cooldownObserver = null;
    let boosterCounts = {}; // MODIFIED: Will now load from localStorage
    let panelBuilt = false;
    let itemListObserver = null;
    let navigationObserver = null;
    let isInitialLoad = true;
    let notificationTimers = {};
    let tabScanTimeout = null;
    let waitForContainerObserver = null;
    let waitForContainerTimeout = null;
    // --- End Global State ---

    // --- Helper Functions ---
    function debugLog(...args) { if (DEBUG_MODE) { console.log('[BoosterAlerts Debug]', ...args); } }
    function getBoosterCategory(id) { id = parseInt(id); if (typeof BOOSTERS === 'undefined') return 'default'; for (const category in BOOSTERS) { if (BOOSTERS[category].some(b => b.id === id)) { return category; } } return 'default'; }
    function getDefaultBoosterColor(id) { const cat = getBoosterCategory(id); return defaultBoosterColors[cat] || defaultBoosterColors.default; }
    function getTextColorForBackground(hexColor) { try { hexColor = hexColor.replace(/^#/, ''); if (hexColor.length === 3) { hexColor = hexColor[0] + hexColor[0] + hexColor[1] + hexColor[1] + hexColor[2] + hexColor[2]; } if (hexColor.length !== 6) { return '#FFFFFF'; } const r = parseInt(hexColor.substring(0, 2), 16); const g = parseInt(hexColor.substring(2, 4), 16); const b = parseInt(hexColor.substring(4, 6), 16); const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255; return luminance > 0.5 ? '#000000' : '#FFFFFF'; } catch (e) { console.error("Error calculating text color:", hexColor, e); return '#FFFFFF'; } }
    function findHeader() { if (window.location.href.includes('torn.com/forums.php')) { const forumHeader = document.querySelector('div.content-title.m-bottom10'); if (forumHeader) return forumHeader; const skipToContent = document.getElementById('skip-to-content'); if (skipToContent) { const p = skipToContent.closest('.content-title, .page-head'); if(p) return p; } } const selectors = ['.appHeader___gUnYC', '.content-title', '.tutorial-cont', '.cont-gray', '.content-wrapper .header', '.content-wrapper .title-black', '.captionWithActionContainment___nVTbE', '.pageTitle___CaFrO', '.sortable-list .title', '.topSection___CfKvI', '.mainStatsContainer___TXO7F', 'div[role="heading"]', '#mainContainer > div.content-wrapper.winter > div.content-title.m-bottom10 h4', '.titleContainer___QrlWP .title___rhtB4', 'div.content-title h4', '.title-black', '.clearfix .t-black', '.page-head > h4', '#react-root > div > div.appHeader___gUnYC.crimes-app-header > h4', 'div.appHeader___gUnYC h4', '#skip-to-content', '.header-title', '.mobile-title', '.app-header']; return selectors.map(s => document.querySelector(s)).find(h => h !== null) || createFixedHeader(); }
    function createFixedHeader() { let fh = document.getElementById('torn-booster-fixed-header'); if (!fh) { fh = document.createElement('div'); fh.id = 'torn-booster-fixed-header'; Object.assign(fh.style, { position: 'fixed', top: '50px', right: '20px', zIndex: '9999', backgroundColor: 'rgba(34, 34, 34, 0.8)', padding: '5px 10px', borderRadius: '5px', display: 'flex', alignItems: 'center', boxShadow: '0 2px 5px rgba(0,0,0,0.3)' }); document.body.appendChild(fh); } return fh; }
    function positionBoosterAlert(alert, header) { if (!header || !header.appendChild) { console.error("BoosterAlerts: Invalid header element provided for positioning.", header); header = createFixedHeader(); } try { if (window.location.href.includes('torn.com/forums.php')) { debugLog('Positioning alert for forum page'); const l = header.querySelector('.links-top-wrap'); if (l) { header.insertBefore(alert, l); } else { const h4 = header.querySelector('h4'); if (h4) { if (h4.nextSibling) header.insertBefore(alert, h4.nextSibling); else header.appendChild(alert); } else { header.appendChild(alert); } } alert.style.cssText = `display: inline-flex !important; align-items: center !important; margin-left: 15px !important; float: right !important; position: relative !important; z-index: 99999 !important; margin-top: 5px !important;`; } else { header.appendChild(alert); alert.style.cssText = `display: inline-flex !important; align-items: center !important; margin-left: 10px !important; order: 2 !important; z-index: 99999 !important; pointer-events: auto !important;`; const mob = navigator.userAgent.includes('PDA') || window.innerWidth < 768 || document.documentElement.classList.contains('tornPDA'); if (mob) { alert.style.fontSize = '10px'; alert.style.padding = '3px 6px'; alert.style.marginLeft = '5px'; } if (header.id === 'torn-booster-fixed-header') { alert.style.margin = '0'; alert.style.marginLeft = '5px'; } } } catch (e) { console.error("BoosterAlerts: Error positioning alert button.", e, "Header:", header, "Alert:", alert); if (alert && !alert.parentElement) { document.body.appendChild(alert); alert.style.position = 'fixed'; alert.style.top = '60px'; alert.style.right = '30px'; alert.style.zIndex = '10000'; } } }
    function removeExistingAlertsAndGui() { const alertBtn = document.querySelector('.booster-alert'); if (alertBtn) alertBtn.remove(); const mainGui = document.getElementById('boosterGui'); if (mainGui) mainGui.remove(); const custUi = document.getElementById('booster-customization-ui'); if (custUi) custUi.remove(); const addUi = document.getElementById('add-boosters-ui'); if (addUi) addUi.remove(); const notifications = document.querySelectorAll('.booster-notification'); notifications.forEach(n => n.remove()); if (alertElements) alertElements = null; }
    // --- End Helper Functions ---

    // --- Styles (Unchanged) ---
    GM_addStyle(`
        /* --- Base Styles --- */
        .booster-alert { background-color: #2196F3; color: white; padding: 5px 10px; border-radius: 3px; font-weight: bold; cursor: pointer; margin-left: 15px; display: inline-flex; align-items: center; font-size: 12px; }
        .booster-gui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #222; color: white; padding: 20px; border-radius: 8px; z-index: 99999999; width: 90vw; max-width: 500px; max-height: 80vh; overflow-y: auto; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.7); border: 1px solid #444; box-sizing: border-box; }
        .booster-gui h3 { margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .booster-search { width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #444; background-color: #333; color: white; border-radius: 3px; box-sizing: border-box; }
        .booster-search::placeholder { color: #aaa; }
        .category-header { margin-top: 15px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #333; font-weight: bold; color: #4CAF50; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .toggle-category { background-color: #333; color: white; border: 1px solid #444; border-radius: 3px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; font-size: 14px; }
        .booster-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 5px; }
        .booster-item { background-color: #333; padding: 12px; border-radius: 5px; text-align: center; cursor: pointer; transition: background-color 0.2s; font-size: 13px; font-weight: bold; word-wrap: break-word; }
        .energy-item { border-left: 3px solid #4CAF50; }
        .nerve-item { border-left: 3px solid #F44336; }
        .happy-item { border-left: 3px solid #FFEB3B; color: white; /* Ensure contrast */ }
        .stat-item { border-left: 3px solid #2196F3; }
        .booster-item:hover { background-color: #444; }
        .booster-notification { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 15px 20px; border-radius: 5px; color: white; z-index: 999999; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4); opacity: 1; transition: opacity 0.5s, transform 0.3s ease-out; text-align: center; min-width: 250px; max-width: 80%; pointer-events: none; }
        .booster-notification.success { background-color: rgba(76, 175, 80, 0.9); border: 1px solid #4CAF50; }
        .booster-notification.error { background-color: rgba(244, 67, 54, 0.9); border: 1px solid #f44336; }
        .booster-notification.info { background-color: rgba(33, 150, 243, 0.9); border: 1px solid #2196F3; }
        /* Style for the timer span inside notification */
        .booster-notification .counter-wrap { font-weight: bold; /* Example style */ }

        /* --- Quick Use Styles (Booster Specific) --- */
        .booster-quick-use-container { position: fixed; right: 20px; background-color: rgba(34, 34, 34, 0.85); padding: 10px; border-radius: 5px; z-index: 9998; display: flex; flex-direction: column; gap: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: top 0.3s ease, padding 0.3s ease; border: 1px solid #555; max-width: 180px; }
        .booster-quick-button { /* color set dynamically */ border: 1px solid #555; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-weight: bold; margin-bottom: 5px; text-align: left; /* Align text left */ transition: background-color 0.2s, filter 0.2s; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; /* Use flex for name and count */ justify-content: space-between; /* Space out name and count */ align-items: center; }
        .booster-quick-button-name { /* NEW: Span for the name */ overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; /* Allow name to take space */ margin-right: 5px; /* Space before count */ }
        .booster-quick-button-count { /* NEW: Span for the count */ font-size: 11px; font-weight: normal; background-color: rgba(0, 0, 0, 0.2); padding: 1px 4px; border-radius: 2px; margin-left: 5px; flex-shrink: 0; /* Prevent count from shrinking */ min-width: 18px; /* Ensure space for 'x##' */ text-align: right; }
        .booster-quick-button:hover { filter: brightness(1.2); }
        .booster-settings-button { background-color: #555; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-weight: bold; /* Removed margin-top */ text-align: center; font-size: 12px; transition: background-color 0.2s; }
        .booster-settings-button:hover { background-color: #666; }
        .booster-quick-use-toggle-button { position: absolute; top: -4px; right: -14px; background-color: #2196F3; color: white; border: none; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 10px; font-weight: bold; box-shadow: 0 1px 3px rgba(0,0,0,0.5); z-index: 1; }

        /* *** UPDATED: Styles for Faction Toggle SLIDER in Quick Use Panel *** */
        .quick-use-faction-toggle-container { /* Wrapper for slider and label */ display: flex; align-items: center; justify-content: space-between; /* Space slider and label */ padding: 4px 0 8px 0; margin-bottom: 5px; border-bottom: 1px solid #444; }
        .quick-use-faction-slider { width: 40px; /* Slider width */ height: 20px; /* Slider height */ background-color: #555; /* Default background */ border-radius: 10px; /* Rounded slider */ position: relative; cursor: pointer; transition: background-color 0.3s ease; flex-shrink: 0; /* Prevent shrinking */ }
        .quick-use-faction-slider-handle { width: 16px; /* Handle size */ height: 16px; background-color: #ccc; border-radius: 50%; /* Circular handle */ position: absolute; top: 2px; left: 2px; /* Initial position (Inventory) */ transition: left 0.3s ease; }
        .quick-use-faction-slider.inventory { background-color: #4CAF50; /* Green for Inventory */ }
        .quick-use-faction-slider.faction { background-color: #F44336; /* Red for Faction */ }
        .quick-use-faction-slider.faction .quick-use-faction-slider-handle { left: calc(100% - 16px - 2px); /* Move handle to the right */ }
        .quick-use-faction-toggle-label { font-size: 11px; color: #ccc; margin-left: 8px; /* Space between slider and label */ flex-grow: 1; /* Allow label to take space */ text-align: right; }
        /* Hide toggle when panel is minimized */
        .booster-quick-use-container[data-minimized="true"] .quick-use-faction-toggle-container { display: none; }
        /* *** END: Slider Styles *** */

        /* --- Customization UI Styles --- */
        #booster-customization-ui, #add-boosters-ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #222; color: white; padding: 20px; border-radius: 8px; z-index: 9999998; width: 90vw; max-width: 400px; max-height: 70vh; overflow-y: auto; box-shadow: 0 4px 15px rgba(0,0,0,0.7); border: 1px solid #444; box-sizing: border-box; }
        #booster-customization-ui h3, #add-boosters-ui h3 { margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px; }
        #booster-customization-ui p { margin-bottom: 15px; font-size: 14px; }
        .booster-selection-area, .add-booster-list-container { margin-bottom: 15px; border: 1px solid #444; border-radius: 5px; padding: 10px; max-height: 250px; overflow-y: auto; background-color: #2a2a2a; }
        .booster-selection-item, .add-booster-item { display: flex; align-items: center; padding: 8px; margin-bottom: 5px; background-color: #333; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; border: 1px solid #444; }
        .booster-selection-item span:first-of-type { margin-right: 10px; cursor: move; user-select: none; color: #888; } /* Drag handle */
        .booster-selection-item input[type="checkbox"], .add-booster-item input[type="checkbox"] { margin-right: 10px; flex-shrink: 0; }
        .booster-selection-item span:nth-of-type(2), .add-booster-item span { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 10px; } /* Name */
        .booster-selection-item input[type="color"] { width: 30px; height: 30px; border: 1px solid #555; background: none; cursor: pointer; vertical-align: middle; margin-left: auto; padding: 0; flex-shrink: 0; border-radius: 3px; } /* Color picker */
        .booster-customization-button { background-color: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; flex-grow: 1; margin: 0 5px; transition: background-color 0.2s; font-size: 13px; font-weight: bold; }
        .booster-customization-button.cancel { background-color: #f44336; }
        .booster-customization-button.add { width: calc(100% - 10px); margin-bottom: 15px; box-sizing: border-box; background-color: #2196F3; }
        .booster-customization-button:hover { filter: brightness(1.1); }
        .booster-customization-button-container { display: flex; justify-content: space-between; margin-top: 15px; }
        #add-boosters-ui input[type="text"] { width: 100%; padding: 10px; margin-bottom: 15px; background-color: #333; border: 1px solid #444; border-radius: 4px; color: white; box-sizing: border-box; font-size: 14px; }
        .add-booster-item.selected { background-color: #444; border-color: #555; }
        .add-boosters-button-container { display: flex; justify-content: flex-end; margin-top: 15px; }
        .add-boosters-done-button { background-color: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; font-size: 13px; font-weight: bold; }
        .add-boosters-done-button:hover { filter: brightness(1.1); }

        /* SortableJS Helper Classes */
        .sortable-ghost { opacity: 0.4; background: #444; }
        .sortable-chosen, .sortable-drag { opacity: 1 !important; }
    `);
    // --- End Styles ---

    // --- Main Alert & GUI Functions (Unchanged from previous version) ---
    function createAlert() { let header = findHeader(); const existingAlert = document.querySelector('.booster-alert'); if (existingAlert) existingAlert.remove(); const existingGui = document.getElementById('boosterGui'); if (existingGui) existingGui.remove(); alertElements = null; const alert = document.createElement('div'); alert.className = 'booster-alert'; alert.textContent = 'No Boosters'; alert.style.cursor = 'pointer'; alert.style.backgroundColor = '#2196F3'; positionBoosterAlert(alert, header); const isItemsPage = window.location.href.includes('torn.com/item.php'); const isFactionArmouryPage = window.location.href.includes('factions.php') && window.location.hash.startsWith('#/tab=armoury'); debugLog(`Page check - Items: ${isItemsPage}, Faction Armoury: ${isFactionArmouryPage}`); let gui = document.getElementById('boosterGui'); if (!gui) { gui = document.createElement('div'); gui.className = 'booster-gui'; gui.id = 'boosterGui'; gui.innerHTML = `<h3>Take Boosters</h3><input type="text" class="booster-search" placeholder="Search boosters..."><div class="category-header energy-header" data-category="energy"><span>Energy Boosters</span><button class="toggle-category">-</button></div><div class="booster-list energy-list"></div><div class="category-header nerve-header" data-category="nerve"><span>Nerve Boosters</span><button class="toggle-category">-</button></div><div class="booster-list nerve-list"></div><div class="category-header happy-header" data-category="happy"><span>Happy Boosters</span><button class="toggle-category">-</button></div><div class="booster-list happy-list"></div><div class="category-header statEnhancers-header" data-category="statEnhancers"><span>Stat Enhancers</span><button class="toggle-category">-</button></div><div class="booster-list statEnhancers-list"></div>`; document.body.appendChild(gui); const searchInput = gui.querySelector('.booster-search'); searchInput.addEventListener('input', function() { const term = this.value.toLowerCase(); gui.querySelectorAll('.booster-item').forEach(item => { const name = item.getAttribute('data-name').toLowerCase(); item.style.display = (term === '' || name.includes(term)) ? 'block' : 'none'; }); Object.keys(BOOSTERS).forEach(cat => { const h = gui.querySelector(`.${cat}-header`); const l = gui.querySelector(`.${cat}-list`); const vis = Array.from(l.querySelectorAll('.booster-item')).filter(i => i.style.display !== 'none').length; h.style.display = vis > 0 ? 'flex' : 'none'; const min = localStorage.getItem(`boosterCategory_${cat}`) === 'minimized'; l.style.display = (vis > 0 && !min) ? 'grid' : 'none'; }); }); function setupCategoryToggles() { Object.keys(BOOSTERS).forEach(cat => { const h = gui.querySelector(`.${cat}-header`); const l = gui.querySelector(`.${cat}-list`); const btn = h.querySelector('.toggle-category'); const min = localStorage.getItem(`boosterCategory_${cat}`) === 'minimized'; l.style.display = min ? 'none' : 'grid'; btn.textContent = min ? '+' : '-'; h.addEventListener('click', (e) => { if (e.target === h || e.target === btn || e.target === h.querySelector('span')) { toggleCategory(cat, l, btn); } }); }); } function toggleCategory(cat, list, btn) { const vis = list.style.display !== 'none'; if (vis) { list.style.display = 'none'; btn.textContent = '+'; localStorage.setItem(`boosterCategory_${cat}`, 'minimized'); } else { list.style.display = 'grid'; btn.textContent = '-'; localStorage.setItem(`boosterCategory_${cat}`, 'expanded'); } } populateBoosterList(gui.querySelector('.energy-list'), BOOSTERS.energy, 'energy-item'); populateBoosterList(gui.querySelector('.nerve-list'), BOOSTERS.nerve, 'nerve-item'); populateBoosterList(gui.querySelector('.happy-list'), BOOSTERS.happy, 'happy-item'); populateBoosterList(gui.querySelector('.statEnhancers-list'), BOOSTERS.statEnhancers, 'stat-item'); setupCategoryToggles(); document.addEventListener('click', function(e) { if (gui && gui.style.display === 'block' && !gui.contains(e.target) && (!alertElements || !alertElements.alert || !alertElements.alert.contains(e.target))) { gui.style.display = 'none'; } }); } alert.onclick = function(event) { debugLog(`Alert clicked. Items page: ${isItemsPage}, Faction Armoury page: ${isFactionArmouryPage}, Using faction boosters: ${useFactionBoosters}`); event.stopPropagation(); const currentGui = document.getElementById('boosterGui'); if ((isItemsPage && !useFactionBoosters) || (isFactionArmouryPage && useFactionBoosters)) { if (currentGui) { currentGui.style.display = currentGui.style.display === 'block' ? 'none' : 'block'; void currentGui.offsetWidth; } else { debugLog("GUI not found on alert click, attempting to recreate."); alertElements = createAlert(); if (alertElements && alertElements.gui) alertElements.gui.style.display = 'block'; } } else { const targetUrl = useFactionBoosters ? 'https://www.torn.com/factions.php?step=your#/tab=armoury' : 'https://www.torn.com/item.php'; sessionStorage.setItem('fromBoosterAlert', 'true'); showNotification(`Navigating to ${useFactionBoosters ? 'faction armoury' : 'items'} page...`, 'info'); window.location.href = targetUrl; } return false; }; return { alert, gui }; }
    function populateBoosterList(container, boosters, className) { container.innerHTML = ''; boosters.forEach(booster => { const item = document.createElement('div'); item.className = `booster-item ${className}`; item.setAttribute('data-name', booster.name); item.setAttribute('data-id', booster.id); item.textContent = booster.effect ? `${booster.name} (${booster.effect})` : booster.name; item.onclick = () => { useBooster(booster.id, booster.name); const g = document.getElementById('boosterGui'); if (g) g.style.display = 'none'; }; container.appendChild(item); }); }
    // --- End Main Alert & GUI ---

    // --- Cooperative Positioning Function (Unchanged) ---
    function adjustBoosterQuickUsePosition() { const boosterPanel = document.querySelector('.booster-quick-use-container'); if (!boosterPanel) { return; } const allQuickUsePanels = document.querySelectorAll('.quick-use-container, .tt-quick-items-container'); let highestBottom = 90; const panelMargin = 10; allQuickUsePanels.forEach(panel => { if (panel.classList.contains('booster-quick-use-container')) return; try { const style = window.getComputedStyle(panel); if (style.display !== 'none' && style.visibility !== 'hidden' && panel.offsetHeight > 0) { const rect = panel.getBoundingClientRect(); if (rect.height > 0 && rect.bottom > 0) { const panelBottom = rect.bottom + window.scrollY; if (panelBottom > highestBottom) { highestBottom = panelBottom; } } else { debugLog("Skipping panel for position calculation due to invalid rect:", panel, rect); } } } catch (e) { console.warn("BoosterAlerts: Error getting geometry for panel:", panel, e); } }); const isBoosterMinimized = localStorage.getItem('boosterAlertMinimized') === 'true'; let targetTop; if (isBoosterMinimized) { targetTop = `${highestBottom + (panelMargin / 2)}px`; } else { targetTop = `${highestBottom + panelMargin}px`; } if (boosterPanel.style.top !== targetTop) { boosterPanel.style.top = targetTop; debugLog(`Adjusted Booster Quick Use panel top to: ${targetTop}`); } }
    function setupCooperativePositioning() { debugLog("[setupPositioning] Setting up cooperative positioning observer and interval."); if (coopObserver) coopObserver.disconnect(); if (coopAdjustInterval) clearInterval(coopAdjustInterval); setTimeout(adjustBoosterQuickUsePosition, 500); coopObserver = new MutationObserver((mutations) => { const panelChanged = mutations.some(mutation => { const checkNode = (node) => node && node.nodeType === 1 && ((node.classList && node.classList.contains('quick-use-container') && !node.classList.contains('booster-quick-use-container')) || (node.classList && node.classList.contains('tt-quick-items-container')) || node.querySelector('.quick-use-container:not(.booster-quick-use-container), .tt-quick-items-container')); const targetIsRelevant = checkNode(mutation.target); const added = Array.from(mutation.addedNodes).some(checkNode); const removed = Array.from(mutation.removedNodes).some(checkNode); const attributeChanged = mutation.type === 'attributes' && (mutation.attributeName === 'style' || mutation.attributeName === 'class'); return added || removed || (targetIsRelevant && attributeChanged); }); if (panelChanged) { debugLog('[setupPositioning] External panel change detected. Re-adjusting booster panel position.'); clearTimeout(window.boosterAlertAdjustTimeout); window.boosterAlertAdjustTimeout = setTimeout(adjustBoosterQuickUsePosition, 150); } }); try { coopObserver.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['style', 'class'] }); } catch (e) { console.error("BoosterAlerts: Failed to observe body for cooperative positioning:", e); } let adjustAttempts = 0; const maxAdjustAttempts = 15; setTimeout(() => { debugLog('[setupPositioning] Starting periodic position adjustment checks...'); coopAdjustInterval = setInterval(() => { adjustBoosterQuickUsePosition(); adjustAttempts++; if (adjustAttempts >= maxAdjustAttempts) { clearInterval(coopAdjustInterval); debugLog('[setupPositioning] Finished periodic position adjustment checks.'); } }, 1000); }, 3000); window.addEventListener('load', () => { debugLog('[setupPositioning] Window load event: Running final position adjustment.'); setTimeout(adjustBoosterQuickUsePosition, 500); }); }
    // --- End Cooperative Positioning ---

    // --- Booster Count Fetching --- MODIFIED TO USE LOCALSTORAGE ---
    function fetchInitialBoosterCounts(useFaction = false, container = document) {
        debugLog(`[fetchCounts] Starting count fetch. Faction mode: ${useFaction}. Container:`, container);

        // MODIFIED: Load from localStorage
        let storedCounts = {};
        try {
            const storedData = localStorage.getItem(LOCAL_STORAGE_KEY); // Use localStorage key
            if (storedData) {
                storedCounts = JSON.parse(storedData);
                if (typeof storedCounts !== 'object' || storedCounts === null) {
                    storedCounts = {};
                }
                debugLog('[fetchCounts] Loaded counts from localStorage:', JSON.stringify(storedCounts));
            }
        } catch (e) {
            console.error("BoosterAlerts: Error parsing stored counts from localStorage", e);
            storedCounts = {};
        }
        boosterCounts = { ...storedCounts }; // Initialize global counts

        // Selectors and DOM scanning logic (unchanged)
        const itemsSelector = useFaction
            ? '#faction-armoury ul.item-list > li, #armoury-boosters ul.item-list > li, #armoury-medical ul.item-list > li, #armoury-drugs ul.item-list > li, #armoury-temporary ul.item-list > li'
            : 'li[data-item]';
        let itemElements = [];
        try { itemElements = Array.from(container.querySelectorAll(itemsSelector)); debugLog(`[fetchCounts] Found ${itemElements.length} potential item elements using selector: "${itemsSelector}" within container.`); }
        catch (e) { console.error(`[fetchCounts] Error querying selector "${itemsSelector}":`, e); itemElements = []; }
        if (!useFaction && itemElements.length === 0) { const altSelector = 'li[id^="item"]'; debugLog(`[fetchCounts] Primary selector "${itemsSelector}" failed for personal items, trying alternative: ${altSelector}`); try { const altItemElements = Array.from(container.querySelectorAll(altSelector)); if (altItemElements.length > 0) { itemElements = altItemElements; debugLog(`[fetchCounts] Found ${altItemElements.length} elements with alternative selector.`); } } catch(e) { console.error(`[fetchCounts] Error querying alternative selector "${altSelector}":`, e); } }

        if (itemElements.length === 0) { console.warn("[fetchCounts] No item elements found on current tab/view."); }
        else {
            itemElements.forEach((itemLi, index) => {
                if (!(itemLi instanceof HTMLElement)) { return; }
                try {
                    let itemId = null; let quantity = null; let itemName = null;
                    if (useFaction) { const imgWrap = itemLi.querySelector('div.img-wrap[data-itemid]'); itemId = imgWrap?.dataset.itemid; const nameDiv = itemLi.querySelector('div.name'); const qtySpan = nameDiv?.querySelector('span.qty'); if (itemId && nameDiv) { itemName = nameDiv.firstChild?.textContent?.trim().replace(/ x$/, '').trim() || `Faction Item ${itemId}`; if (qtySpan?.textContent) { quantity = parseInt(qtySpan.textContent.replace(/[\D]/g, '')); } else { const nameMatch = nameDiv.textContent.match(/ x(\d+)$/); if (nameMatch && nameMatch[1]) { quantity = parseInt(nameMatch[1]); itemName = nameDiv.textContent.substring(0, nameMatch.index).trim(); } else { quantity = 1; debugLog(`[fetchCounts Faction] No qty span/suffix found for ${itemName} (ID: ${itemId}), assuming quantity is 1.`); } } } else { debugLog(`[fetchCounts Faction] Skipping item, couldn't find ID or name div:`, itemLi); return; } }
                    else { const isActionItem = itemLi.classList.contains('dump') || itemLi.classList.contains('send') || itemLi.classList.contains('market') || itemLi.classList.contains('equip') || itemLi.classList.contains('unequip') || itemLi.classList.contains('info') || !itemLi.querySelector('.title-wrap'); if (isActionItem) { return; } itemId = itemLi.getAttribute('data-item') || itemLi.getAttribute('data-itemid'); if (!itemId && itemLi.id && itemLi.id.startsWith('item')) { itemId = itemLi.id.replace('item', ''); } if (!itemId) { const img = itemLi.querySelector('img.torn-item[src*="/items/"]'); if (img?.src) { const match = img.src.match(/\/items\/(\d+)\//); if (match && match[1]) itemId = match[1]; } } if (!itemId) return; const nameElement = itemLi.querySelector('.name, .title .name, .name-wrap .t-overflow'); itemName = nameElement ? nameElement.textContent.trim() : `Unknown (ID: ${itemId})`; const dataQty = itemLi.getAttribute('data-qty'); if (dataQty !== null) { const qtyFromAttr = parseInt(dataQty); if (!isNaN(qtyFromAttr) && qtyFromAttr >= 0) { quantity = qtyFromAttr; } } if (quantity === null) { const qtyElement = itemLi.querySelector('.title-wrap .name-wrap span.qty'); if (qtyElement?.textContent) { const qtyText = qtyElement.textContent.replace(/[\D]/g, ''); const qtyFromSpan = parseInt(qtyText); if (!isNaN(qtyFromSpan) && qtyFromSpan >= 0) { quantity = qtyFromSpan; } } } }
                    itemId = parseInt(itemId); if (isNaN(itemId)) return;
                    if (quantity !== null && !isNaN(quantity) && quantity >= 0) { boosterCounts[itemId] = quantity; }
                    else { if (boosterCounts[itemId] === undefined) { debugLog(`[fetchCounts] Failed to parse valid quantity for ${itemName} (ID: ${itemId}). Storing 0.`, itemLi); boosterCounts[itemId] = 0; } }
                } catch (e) { console.error(`[fetchCounts] Error processing element index ${index}:`, itemLi, e); }
            });
        }

        // MODIFIED: Save updated counts to localStorage
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(boosterCounts)); // Use localStorage
            debugLog("[fetchCounts] Saved updated counts to localStorage:", JSON.stringify(boosterCounts));
        } catch (e) {
            console.error("BoosterAlerts: Error saving counts to localStorage", e);
        }
    }

    // MODIFIED TO USE LOCALSTORAGE
    function updateBoosterCountDisplay(boosterId, newCount) {
        boosterId = parseInt(boosterId); newCount = parseInt(newCount);
        if (isNaN(boosterId) || isNaN(newCount)) { console.error("[updateCount] Invalid ID or count provided:", boosterId, newCount); return; }

        boosterCounts[boosterId] = newCount; // Update global state

        // MODIFIED: Update localStorage
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(boosterCounts)); // Use localStorage
            // debugLog(`[updateCount] Updated localStorage for booster ${boosterId} to count ${newCount}`); // Reduce noise
        } catch (e) {
            console.error("BoosterAlerts: Error saving updated count to localStorage", e);
        }

        // Update UI (unchanged logic)
        let button = document.querySelector(`.booster-quick-button[data-booster-id="${boosterId}"]`);
        const quickUseContainer = document.querySelector('.booster-quick-use-container');
        if (!button && newCount > 0 && quickUseContainer) { debugLog(`[updateCount] Button for ${boosterId} not found, creating as count is ${newCount}`); const savedBoosters = JSON.parse(localStorage.getItem('customQuickUseBoosters') || '[]'); const boosterData = savedBoosters.find(b => parseInt(b.id) === boosterId); if (boosterData) { button = createQuickUseButtonElement(boosterData, newCount); const settingsButton = quickUseContainer.querySelector('.booster-settings-button'); if (settingsButton) { quickUseContainer.insertBefore(button, settingsButton); } else { quickUseContainer.appendChild(button); } const isMinimized = localStorage.getItem('boosterAlertMinimized') === 'true'; if (isMinimized) button.style.display = 'none'; } else { debugLog(`[updateCount] Could not find booster data for ID ${boosterId} to create button.`); } }
        else if (button) { const countSpan = button.querySelector('.booster-quick-button-count'); if (countSpan) { countSpan.textContent = `x${newCount}`; const isMinimized = localStorage.getItem('boosterAlertMinimized') === 'true'; button.style.display = isMinimized ? 'none' : (newCount > 0 ? 'flex' : 'none'); } else { debugLog(`[updateCount] Count span not found for booster ${boosterId}`); } }
    }
    // --- END Booster Count Fetching ---

    // --- Quick Use Functions --- (MODIFIED buildOrRebuildQuickUsePanel for localStorage)
    function createQuickUseButtonElement(booster, count) { const boosterIdNum = parseInt(booster.id); const btn = document.createElement('div'); btn.className = 'booster-quick-button'; btn.setAttribute('data-booster-id', boosterIdNum); btn.setAttribute('data-booster-name', booster.name); const nameSpan = document.createElement('span'); nameSpan.className = 'booster-quick-button-name'; nameSpan.textContent = booster.name; const countSpan = document.createElement('span'); countSpan.className = 'booster-quick-button-count'; countSpan.textContent = `x${count}`; btn.appendChild(nameSpan); btn.appendChild(countSpan); const bgColor = booster.color || getDefaultBoosterColor(boosterIdNum); btn.style.backgroundColor = bgColor; btn.style.color = getTextColorForBackground(bgColor); btn.addEventListener('click', () => useBooster(boosterIdNum, booster.name)); return btn; }

    // MODIFIED TO USE LOCALSTORAGE FOR FACTION TOGGLE
    function buildOrRebuildQuickUsePanel() {
        debugLog("[buildPanel] Starting build/rebuild...");
        const existingContainer = document.querySelector('.booster-quick-use-container'); if (existingContainer) { debugLog("[buildPanel] Removing existing container."); existingContainer.remove(); }

        // Visibility check (unchanged)
        const isItemsPage = window.location.href.includes('torn.com/item.php'); const isFactionArmouryPage = window.location.href.includes('factions.php') && window.location.hash.startsWith('#/tab=armoury'); const shouldShowQuickUse = (isItemsPage && !useFactionBoosters) || (isFactionArmouryPage && useFactionBoosters);
        debugLog(`[buildPanel] Visibility Check: isItemsPage=${isItemsPage}, isFactionArmouryPage=${isFactionArmouryPage}, useFactionBoosters=${useFactionBoosters}, shouldShowQuickUse=${shouldShowQuickUse}`);
        if (!shouldShowQuickUse) { debugLog('[buildPanel] Quick Use UI should not be shown on this page/mode. Aborting panel build.'); return; }

        // Build Panel
        debugLog('[buildPanel] Creating Quick Use UI container.');
        const quickUseContainer = document.createElement('div'); quickUseContainer.className = 'booster-quick-use-container';
        const savedQuickUseBoosters = localStorage.getItem('customQuickUseBoosters'); let quickUseBoosters = []; const defaultQuickBoosters = [ { id: 532, name: "Can of Red Cow" }, { id: 533, name: "Can of Taurine Elite" }, { id: 530, name: "Can of Munster" } ];
        if (savedQuickUseBoosters) { try { quickUseBoosters = JSON.parse(savedQuickUseBoosters); quickUseBoosters.forEach(b => { b.id = parseInt(b.id); if (!b.color) b.color = getDefaultBoosterColor(b.id); }); } catch (e) { console.error("Booster Alerts: Error parsing saved quick use boosters", e); quickUseBoosters = defaultQuickBoosters.map(b => ({ ...b, id: parseInt(b.id), color: getDefaultBoosterColor(b.id) })); localStorage.setItem('customQuickUseBoosters', JSON.stringify(quickUseBoosters)); } } else { quickUseBoosters = defaultQuickBoosters.map(b => ({ ...b, id: parseInt(b.id), color: getDefaultBoosterColor(b.id) })); localStorage.setItem('customQuickUseBoosters', JSON.stringify(quickUseBoosters)); }
        debugLog("[buildPanel] Loaded quick use boosters config:", quickUseBoosters);

        const boosterButtons = []; let buttonsAddedCount = 0;
        quickUseBoosters.forEach(booster => { const boosterIdNum = parseInt(booster.id); const count = boosterCounts[boosterIdNum] || 0; debugLog(`[buildPanel] Processing: ${booster.name} (ID: ${boosterIdNum}), Count from state: ${count}`); const btn = createQuickUseButtonElement(booster, count); btn.style.display = count > 0 ? 'flex' : 'none'; boosterButtons.push(btn); quickUseContainer.appendChild(btn); if (count > 0) { buttonsAddedCount++; } });
        debugLog(`[buildPanel] Created ${boosterButtons.length} buttons structure, ${buttonsAddedCount} initially visible.`);

        // Faction Toggle Slider
        const toggleContainer = document.createElement('div'); toggleContainer.className = 'quick-use-faction-toggle-container'; const sliderContainer = document.createElement('div'); sliderContainer.className = 'quick-use-faction-slider'; sliderContainer.classList.add(useFactionBoosters ? 'faction' : 'inventory'); const sliderHandle = document.createElement('div'); sliderHandle.className = 'quick-use-faction-slider-handle'; sliderContainer.appendChild(sliderHandle); const sliderLabel = document.createElement('span'); sliderLabel.className = 'quick-use-faction-toggle-label'; sliderLabel.textContent = useFactionBoosters ? 'Faction' : 'Inventory'; toggleContainer.appendChild(sliderContainer); toggleContainer.appendChild(sliderLabel); quickUseContainer.appendChild(toggleContainer);

        // MODIFIED: Slider click handler uses localStorage.removeItem
        sliderContainer.addEventListener('click', function() {
            useFactionBoosters = !useFactionBoosters;
            sliderContainer.classList.toggle('faction', useFactionBoosters); sliderContainer.classList.toggle('inventory', !useFactionBoosters); sliderLabel.textContent = useFactionBoosters ? 'Faction' : 'Inventory';
            localStorage.setItem('useFactionBoosters', useFactionBoosters);
            showNotification(`${useFactionBoosters ? 'Using faction armoury boosters' : 'Using personal inventory boosters'}`, 'info');
            debugLog('[Faction Toggle Slider] Clearing counts and triggering rescan/rebuild.');
            boosterCounts = {}; // Clear in-memory counts
            // MODIFIED: Use localStorage.removeItem
            try {
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear persistent counts for this type
                debugLog("[Faction Toggle Slider] Cleared booster counts from localStorage.");
            } catch (e) {
                console.error("BoosterAlerts: Failed to clear localStorage on source switch", e);
            }
            handleDelayedScan(); // Re-fetch and rebuild
        });

        // Settings Button
        const settingsButton = document.createElement('div'); settingsButton.textContent = '⚙️ Edit Boosters'; settingsButton.className = 'booster-settings-button'; settingsButton.addEventListener('click', () => showBoosterCustomizationUI(quickUseBoosters)); quickUseContainer.appendChild(settingsButton);

        // Minimize Button & Logic
        const toggleButton = document.createElement('button'); toggleButton.className = 'booster-quick-use-toggle-button'; let isMinimized = localStorage.getItem('boosterAlertMinimized') === 'true';
        function applyMinimizedState() { const currentContainer = document.querySelector('.booster-quick-use-container'); if (!currentContainer) return; currentContainer.dataset.minimized = isMinimized.toString(); if (Array.isArray(boosterButtons)) { boosterButtons.forEach(btn => { if (btn instanceof HTMLElement) { const boosterId = btn.getAttribute('data-booster-id'); const currentCount = boosterCounts[boosterId] || 0; btn.style.display = isMinimized ? 'none' : (currentCount > 0 ? 'flex' : 'none'); } }); } if (settingsButton) settingsButton.style.display = isMinimized ? 'none' : 'block'; currentContainer.style.padding = isMinimized ? '2px' : '10px'; toggleButton.textContent = isMinimized ? '+' : '–'; adjustBoosterQuickUsePosition(); }
        toggleButton.addEventListener('click', () => { isMinimized = !isMinimized; localStorage.setItem('boosterAlertMinimized', isMinimized.toString()); applyMinimizedState(); });

        quickUseContainer.appendChild(toggleButton); document.body.appendChild(quickUseContainer);
        applyMinimizedState(); setupCooperativePositioning(); panelBuilt = true;
        debugLog("[buildPanel] Panel build complete.");
    }

    // Customization UI Functions (Unchanged)
    function showBoosterCustomizationUI(currentBoosters) { let justOpened = true; setTimeout(() => { justOpened = false; }, 300); const existingUI = document.getElementById('booster-customization-ui'); if (existingUI) existingUI.remove(); const customizationUI = document.createElement('div'); customizationUI.id = 'booster-customization-ui'; customizationUI.innerHTML = `<h3>Customize Quick Use Boosters</h3><p>Select boosters to show. Drag ≡ to reorder. Click color swatch to customize.</p><div class="booster-selection-area"></div><button class="booster-customization-button add">+ Add More Boosters</button><div class="booster-customization-button-container"><button class="booster-customization-button save">Save Changes</button><button class="booster-customization-button cancel">Cancel</button></div>`; const boosterSelectionArea = customizationUI.querySelector('.booster-selection-area'); const selectedBoosters = JSON.parse(JSON.stringify(currentBoosters)).map(b => ({ ...b, id: parseInt(b.id), color: b.color || getDefaultBoosterColor(parseInt(b.id)) })); function createColorPicker(booster) { const c = document.createElement('input'); c.type = 'color'; c.value = booster.color || getDefaultBoosterColor(booster.id); c.addEventListener('input', (e) => { const itemData = selectedBoosters.find(b => b.id === booster.id); if (itemData) itemData.color = e.target.value; }); c.addEventListener('click', (e) => e.stopPropagation()); return c; } function renderBoosterItem(booster) { const boosterIdNum = parseInt(booster.id); const i = document.createElement('div'); i.className = 'booster-selection-item'; i.setAttribute('data-booster-id', boosterIdNum); i.setAttribute('draggable', 'true'); const h = document.createElement('span'); h.innerHTML = '≡'; i.appendChild(h); const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = true; cb.addEventListener('change', () => { i.style.opacity = cb.checked ? '1' : '0.5'; i.style.textDecoration = cb.checked ? 'none' : 'line-through'; if (!cb.checked) i.setAttribute('data-remove', 'true'); else i.removeAttribute('data-remove'); }); i.appendChild(cb); const n = document.createElement('span'); n.textContent = booster.name; i.appendChild(n); const cp = createColorPicker(booster); i.appendChild(cp); boosterSelectionArea.appendChild(i); } selectedBoosters.forEach(renderBoosterItem); function updateOrderAfterDrag() { const items = Array.from(boosterSelectionArea.querySelectorAll('.booster-selection-item')); const reordered = []; items.forEach(item => { const id = parseInt(item.dataset.boosterId); let data = selectedBoosters.find(b => b.id === id); if (data) { const cp = item.querySelector('input[type="color"]'); if (cp) data.color = cp.value; reordered.push(data); } else { const originalBooster = allBoostersFlat.find(b => b.id === id); if (originalBooster) { const cp = item.querySelector('input[type="color"]'); reordered.push({ id: id, name: originalBooster.name, color: cp ? cp.value : getDefaultBoosterColor(id) }); } } }); selectedBoosters.length = 0; selectedBoosters.push(...reordered); debugLog("Updated booster order:", selectedBoosters); } if (typeof Sortable !== 'undefined') { try { Sortable.create(boosterSelectionArea, { animation: 150, handle: '.booster-selection-item span:first-of-type', ghostClass: 'sortable-ghost', chosenClass: 'sortable-chosen', dragClass: 'sortable-drag', onEnd: updateOrderAfterDrag }); } catch(e) { console.error("SortableJS initialization failed:", e); addManualDragListeners(boosterSelectionArea, updateOrderAfterDrag); } } else { console.warn("BoosterAlerts: SortableJS not found. Using manual drag/drop."); addManualDragListeners(boosterSelectionArea, updateOrderAfterDrag); } customizationUI.querySelector('.booster-customization-button.add').addEventListener('click', () => { showAddBoostersUI(selectedBoosters, boosterSelectionArea, renderBoosterItem); }); customizationUI.querySelector('.booster-customization-button.save').addEventListener('click', () => { const currentItemsInUI = Array.from(boosterSelectionArea.querySelectorAll('.booster-selection-item')); const finalBoostersCorrected = currentItemsInUI .filter(item => !item.hasAttribute('data-remove')) .map(item => { const boosterId = parseInt(item.dataset.boosterId); const boosterData = selectedBoosters.find(b => b.id === boosterId); const colorPicker = item.querySelector('input[type="color"]'); return { id: boosterId, name: boosterData ? boosterData.name : allBoostersFlat.find(b => b.id === boosterId)?.name || 'Unknown', color: colorPicker ? colorPicker.value : (boosterData ? boosterData.color : getDefaultBoosterColor(boosterId)) }; }); localStorage.setItem('customQuickUseBoosters', JSON.stringify(finalBoostersCorrected)); customizationUI.remove(); buildOrRebuildQuickUsePanel(); showNotification('Quick use boosters updated!', 'success'); }); customizationUI.querySelector('.booster-customization-button.cancel').addEventListener('click', () => { customizationUI.remove(); const addUI = document.getElementById('add-boosters-ui'); if (addUI) addUI.remove(); }); document.body.appendChild(customizationUI); function closeOnClickOutside(e) { if (justOpened) return; const isSettings = e.target.closest('.booster-settings-button'); const isAddUI = e.target.closest('#add-boosters-ui'); const isCustomizationUI = e.target.closest('#booster-customization-ui'); if (!isCustomizationUI && !isSettings && !isAddUI) { customizationUI.remove(); const addUI = document.getElementById('add-boosters-ui'); if (addUI) addUI.remove(); document.removeEventListener('click', closeOnClickOutside, true); } } setTimeout(() => { document.addEventListener('click', closeOnClickOutside, true); }, 100); }
    function addManualDragListeners(area, onEndCallback) { let draggedItemElement = null; area.addEventListener('dragstart', (e) => { draggedItemElement = e.target.closest('.booster-selection-item'); if (!draggedItemElement) return; e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemElement.dataset.boosterId); setTimeout(() => { if (draggedItemElement) draggedItemElement.style.opacity = '0.4'; }, 0); }); area.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetElement = e.target.closest('.booster-selection-item'); if (targetElement && targetElement !== draggedItemElement) { const rect = targetElement.getBoundingClientRect(); const midpoint = rect.top + rect.height / 2; if (e.clientY < midpoint) { area.insertBefore(draggedItemElement, targetElement); } else { area.insertBefore(draggedItemElement, targetElement.nextSibling); } } }); area.addEventListener('drop', (e) => { e.preventDefault(); }); area.addEventListener('dragend', (e) => { if (draggedItemElement) { draggedItemElement.style.opacity = '1'; } draggedItemElement = null; if (typeof onEndCallback === 'function') { onEndCallback(); } }); }
    function showAddBoostersUI(selectedBoostersRef, parentBoosterSelectionArea, renderBoosterItemFn) { const existingAddUI = document.getElementById('add-boosters-ui'); if (existingAddUI) existingAddUI.remove(); const addUI = document.createElement('div'); addUI.id = 'add-boosters-ui'; addUI.innerHTML = `<h3>Add Boosters to Quick Use</h3><input type="text" placeholder="Search all boosters..."><div class="add-booster-list-container"></div><div class="add-boosters-button-container"><button class="add-boosters-done-button">Done</button></div>`; const searchBox = addUI.querySelector('input[type="text"]'); const listContainer = addUI.querySelector('.add-booster-list-container'); function refreshList(term = '') { listContainer.innerHTML = ''; const filtered = allBoostersFlat.filter(b => b.name.toLowerCase().includes(term.toLowerCase())); if (filtered.length === 0) { listContainer.innerHTML = '<div style="padding: 10px; color: #aaa;">No boosters found</div>'; return; } filtered.forEach(b => { const boosterIdNum = parseInt(b.id); const pItem = parentBoosterSelectionArea.querySelector(`.booster-selection-item[data-booster-id="${boosterIdNum}"]`); const isSel = pItem && !pItem.hasAttribute('data-remove'); const item = document.createElement('div'); item.className = `add-booster-item ${isSel ? 'selected' : ''}`; const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = isSel; cb.style.pointerEvents = 'none'; const name = document.createElement('span'); name.textContent = b.name; item.appendChild(cb); item.appendChild(name); item.addEventListener('click', () => { const pOnClick = parentBoosterSelectionArea.querySelector(`.booster-selection-item[data-booster-id="${boosterIdNum}"]`); const currentSel = pOnClick && !pOnClick.hasAttribute('data-remove'); if (!currentSel) { if (pOnClick) { pOnClick.style.opacity = '1'; pOnClick.style.textDecoration = 'none'; pOnClick.removeAttribute('data-remove'); const pCb = pOnClick.querySelector('input[type="checkbox"]'); if(pCb) pCb.checked = true; if (!selectedBoostersRef.some(r => r.id === boosterIdNum)) { const colorPicker = pOnClick.querySelector('input[type="color"]'); selectedBoostersRef.push({ ...b, id: boosterIdNum, color: colorPicker ? colorPicker.value : getDefaultBoosterColor(boosterIdNum) }); } } else { const newData = { ...b, id: boosterIdNum, color: getDefaultBoosterColor(boosterIdNum) }; renderBoosterItemFn(newData); selectedBoostersRef.push(newData); } item.classList.add('selected'); cb.checked = true; } else { if (pOnClick) { pOnClick.style.opacity = '0.5'; pOnClick.style.textDecoration = 'line-through'; pOnClick.setAttribute('data-remove', 'true'); const pCb = pOnClick.querySelector('input[type="checkbox"]'); if(pCb) pCb.checked = false; } item.classList.remove('selected'); cb.checked = false; } }); listContainer.appendChild(item); }); } refreshList(); searchBox.addEventListener('input', () => { refreshList(searchBox.value); }); addUI.querySelector('.add-boosters-done-button').addEventListener('click', () => { addUI.remove(); }); document.body.appendChild(addUI); addUI.addEventListener('click', e => { e.stopPropagation(); }); }
    // --- End Quick Use Functions ---

    // --- Core Logic (useBooster, XHR requests, etc.) --- (Now uses localStorage via helpers)
    function useBooster(id, name) { const boosterIdNum = parseInt(id); debugLog(`[useBooster] Attempting to use booster: ${name} (ID: ${boosterIdNum}), Using faction boosters: ${useFactionBoosters}`); showNotification(`Using ${name}...`, 'info'); const gui = document.getElementById('boosterGui'); if (gui) gui.style.display = 'none'; const currentCount = boosterCounts[boosterIdNum] || 0; if (currentCount > 0) { updateBoosterCountDisplay(boosterIdNum, currentCount - 1); } else { console.warn(`[useBooster] Attempting to use ${name} (ID: ${boosterIdNum}) with count ${currentCount}`); updateBoosterCountDisplay(boosterIdNum, 0); } if (useFactionBoosters) { tryFactionBoosterUseMethod(boosterIdNum, name, currentCount); } else { tryDirectUseMethod(boosterIdNum, name, currentCount); } }
    function tryDirectUseMethod(id, name, originalCount) { debugLog('[tryDirect] Attempting direct use method'); sessionStorage.setItem('boosterUseInProgress', JSON.stringify({ id, name, timestamp: Date.now(), method: 'direct' })); useItemDirectly(id, name, originalCount); }
    function useItemDirectly(id, name, originalCount) { debugLog(`[useDirect] Using item directly: ${name} (ID: ${id})`); const token = getNSTStyleToken() || getPageCsrfToken(); if (token) { debugLog(`[useDirect] Using token: ${token.substring(0, 4)}...`); submitBoosterUseRequest(id, name, token, originalCount); } else { console.error('BoosterAlerts: Failed to get token'); showNotification(`Unable to use ${name}: Could not get token`, 'error'); sessionStorage.removeItem('boosterUseInProgress'); updateBoosterCountDisplay(id, originalCount); } }
    function tryFactionBoosterUseMethod(id, name, originalCount) { debugLog(`[tryFaction] Attempting faction booster use: ${name} (ID: ${id})`); sessionStorage.setItem('boosterUseInProgress', JSON.stringify({ id, name, timestamp: Date.now(), method: 'faction' })); const isFacArmouryPage = window.location.href.includes('factions.php') && window.location.hash.startsWith('#/tab=armoury'); if (!isFacArmouryPage) { debugLog(`[tryFaction] Not on armoury page. Navigating...`); sessionStorage.setItem('pendingFactionBoosterUse', JSON.stringify({ id, name, originalCount })); window.location.href = 'https://www.torn.com/factions.php?step=your#/tab=armoury'; return; } const token = getNSTStyleToken() || getPageCsrfToken(); if (!token) { console.error('BoosterAlerts: No CSRF token for faction booster'); showNotification('Unable to use faction booster: No token', 'error'); sessionStorage.removeItem('boosterUseInProgress'); updateBoosterCountDisplay(id, originalCount); return; } debugLog(`[tryFaction] Using token for faction booster: ${token.substring(0, 4)}...`); tryBothFactionBoosterMethods(id, name, token, originalCount); }
    function tryBothFactionBoosterMethods(id, name, token, originalCount) { debugLog('[tryBothFaction] Trying direct faction method first (item.php?fac=1)'); useFactionBoosterById(id, name, token, originalCount); setTimeout(() => { const progress = sessionStorage.getItem('boosterUseInProgress'); if (progress) { try { const progressData = JSON.parse(progress); if (progressData && parseInt(progressData.id) === id) { debugLog('[tryBothFaction] Direct faction method failed/slow, trying traditional'); useFactionBoosterDirectly(id, name, originalCount); } } catch (e) { console.error("Error parsing boosterUseInProgress:", e); sessionStorage.removeItem('boosterUseInProgress'); } } }, 2500); }
    function useFactionBoosterById(id, name, token, originalCount) { debugLog(`[useFacById] Directly using faction booster via item.php?fac=1: ${id}`); const params = new URLSearchParams({ step: 'useItem', confirm: 'yes', itemID: id, fac: '1', csrf: token }); const xhr = new XMLHttpRequest(); xhr.open('POST', 'https://www.torn.com/item.php', true); xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.onload = function() { handleBoosterResponse(this, id, name, 'faction_direct', originalCount, true); }; xhr.onerror = function() { debugLog('[useFacById] Direct faction (item.php) network error'); }; xhr.send(params.toString()); }
    function useFactionBoosterDirectly(id, name, originalCount) { debugLog(`[useFacDirect] Using traditional faction booster method: ${name} (ID: ${id})`); const token = getNSTStyleToken() || getPageCsrfToken(); if (!token) { console.error('BoosterAlerts: No token for traditional faction method'); showNotification('Unable to use faction booster: No token (retry)', 'error'); sessionStorage.removeItem('boosterUseInProgress'); updateBoosterCountDisplay(id, originalCount); return; } useFactionBoosterWithToken(id, name, token, originalCount); }
    function useFactionBoosterWithToken(id, name, token, originalCount) { let armouryItemID = findArmouryItemId(id, name); if (!armouryItemID) { debugLog(`[useFacToken] Could not find specific armouryItemID for ${name} (ID: ${id}), using item ID as fallback.`); armouryItemID = id; } else { debugLog(`[useFacToken] Found specific armouryItemID: ${armouryItemID}`); } debugLog(`[useFacToken] Using faction booster (traditional) with armouryItemID: ${armouryItemID} for item ${name} (ID: ${id})`); const params = new URLSearchParams({ step: 'armoryItemAction', confirm: 'yes', armoryItemID, action: 'use', csrf: token }); const xhr = new XMLHttpRequest(); xhr.open('POST', 'https://www.torn.com/factions.php', true); xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.onload = function() { handleBoosterResponse(this, id, name, 'faction_traditional', originalCount); }; xhr.onerror = function() { debugLog('[useFacToken] Traditional faction network error'); showNotification(`Error using ${name}: Network error`, 'error'); sessionStorage.removeItem('boosterUseInProgress'); updateBoosterCountDisplay(id, originalCount); }; xhr.send(params.toString()); }
    function findArmouryItemId(itemId, itemName) { itemId = parseInt(itemId); const itemTypeSelectors = ['boosters', 'medical', 'drugs', 'temporary']; for (const itemType of itemTypeSelectors) { const selectors = [`#armoury-${itemType} ul.items-list > li[data-itemid="${itemId}"]`, `#faction-armoury .${itemType}-wrap ul.item-list > li[data-id="${itemId}"]`, `div[class*="armory"] div[class*="${itemType}"] div[class*="item"][data-id="${itemId}"]`]; for (const selector of selectors) { const itemLi = document.querySelector(selector); if (itemLi) { debugLog(`[findArmouryId] Found potential itemLi for ${itemName} with selector: ${selector}`); const nameEl = itemLi.querySelector('.name, .title, .item-name, .name-wrap .t-overflow, [class*="name"]'); if (nameEl && nameEl.textContent.trim().toLowerCase() === itemName.toLowerCase()) { const actionLink = itemLi.querySelector('a[href*="armoryItemID="], button[data-id], a[onclick*="armoryItemAction"], div[data-id]'); if (actionLink) { let match = null; if (actionLink.href) match = actionLink.href.match(/armoryItemID=(\d+)/); else if (actionLink.dataset && actionLink.dataset.id) match = [null, actionLink.dataset.id]; else if (actionLink.onclick) match = actionLink.onclick.toString().match(/armoryItemAction\((\d+)/); if (match && match[1]) { debugLog(`[findArmouryId] Extracted armouryItemID ${match[1]} from actionLink`); return match[1]; } } if (itemLi.getAttribute('data-armoryitemid')) { debugLog(`[findArmouryId] Found armouryItemID ${itemLi.getAttribute('data-armoryitemid')} on li attribute`); return itemLi.getAttribute('data-armoryitemid'); } const buttonWithId = itemLi.querySelector('button[data-id]'); if (buttonWithId?.dataset?.id) { debugLog(`[findArmouryId] Extracted armouryItemID ${buttonWithId.dataset.id} from button data-id`); return buttonWithId.dataset.id; } debugLog(`[findArmouryId] Found matching item li for ${itemName}, but couldn't extract specific armouryItemID from action elements.`); } else { debugLog(`[findArmouryId] Found itemLi with ID ${itemId}, but name mismatch. Found: "${nameEl?.textContent.trim()}", Expected: "${itemName}"`); } } } } debugLog(`[findArmouryId] Could not find specific armouryItemID for ${itemName} (ID: ${itemId}). Will use item ID as fallback.`); return null; }
    function submitBoosterUseRequest(id, name, token, originalCount) { const params = new URLSearchParams({ step: 'useItem', confirm: 'yes', itemID: id, csrf: token }); const xhr = new XMLHttpRequest(); xhr.open('POST', 'https://www.torn.com/item.php', true); xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.onload = function() { handleBoosterResponse(this, id, name, 'personal', originalCount); }; xhr.onerror = function() { debugLog('[submitRequest] Personal booster network error'); showNotification(`Error using ${name}: Network error`, 'error'); sessionStorage.removeItem('boosterUseInProgress'); updateBoosterCountDisplay(id, originalCount); }; xhr.send(params.toString()); }
    function handleBoosterResponse(xhr, id, name, method, originalCount, maybeClearProgress = false) { id = parseInt(id); let success = false; let cooldown = false; let message = `Error using ${name}: Unknown response`; let isJson = false; let responseData = null; let rawResponseText = xhr.responseText || ''; debugLog(`[handleResponse ${method}] Received response for ${name} (ID: ${id}). Original count: ${originalCount}`); if (xhr.status === 200) { try { responseData = JSON.parse(rawResponseText); isJson = true; debugLog(`[handleResponse ${method}] JSON Response:`, responseData); const responseTextFromJson = responseData.text || responseData.message || (responseData.error ? JSON.stringify(responseData.error) : ''); if (responseData.success) { success = true; message = responseTextFromJson || `Used ${name} successfully!`; } else if (responseTextFromJson && responseTextFromJson.includes('<span class="counter-wrap"')) { cooldown = true; success = false; message = responseTextFromJson; debugLog(`[handleResponse ${method}] Detected cooldown with timer span (JSON).`); } else if (responseTextFromJson && (responseTextFromJson.includes('cooldown') || responseTextFromJson.includes('effect of a booster') || responseTextFromJson.includes('wait'))) { cooldown = true; success = false; message = extractCooldownMessage(responseTextFromJson, 'Booster') || 'You are on booster cooldown or effect already active.'; debugLog(`[handleResponse ${method}] Detected generic cooldown (JSON).`); } else { success = false; const tempDiv = document.createElement('div'); tempDiv.innerHTML = responseTextFromJson || ''; message = `Error: ${(tempDiv.textContent || tempDiv.innerText || responseTextFromJson || 'Unknown error').trim()}`; } } catch (e) { isJson = false; debugLog(`[handleResponse ${method}] Text Response (first 200 chars):`, rawResponseText.substring(0, 200)); if (rawResponseText.includes('<span class="counter-wrap"')) { cooldown = true; success = false; message = rawResponseText; debugLog(`[handleResponse ${method}] Detected cooldown with timer span (HTML/Text).`); } else if (rawResponseText.includes('consumed') || rawResponseText.includes('used')) { success = true; const successMatch = rawResponseText.match(/<div[^>]*class=["'][^"']*success[^"']*["'][^>]*>(.*?)<\/div>/i) || rawResponseText.match(/<p[^>]*class=["'][^"']*msg[^"']*["'][^>]*>(.*?)<\/p>/i); message = successMatch ? (successMatch[1].replace(/<[^>]+>/g, '').trim() || `Used ${name} successfully!`) : `Used ${name} successfully!`; } else if (rawResponseText.includes('cooldown') || rawResponseText.includes('effect of a booster') || rawResponseText.includes('wait')) { cooldown = true; success = false; message = extractCooldownMessage(rawResponseText, 'Booster') || 'You are on booster cooldown or effect already active.'; debugLog(`[handleResponse ${method}] Detected generic cooldown (HTML/Text).`); } else { success = false; const errorMatch = rawResponseText.match(/<[^>]*class=['"]error['"][^>]*>(.*?)<\/|Validation failed|Error:|not authorized/i); if (errorMatch) { message = `Error: ${(errorMatch[1] || 'Validation failed').replace(/<[^>]+>/g, '').trim()}`; } else { message = `Error using ${name}: Unexpected response`; } } } } else { success = false; message = `Error using ${name}: Request failed (${xhr.status})`; } showNotification(message, success ? 'success' : (cooldown ? 'info' : 'error')); if (!success) { debugLog(`[handleResponse ${method}] Usage failed or cooldown for ${name} (ID: ${id}). Reverting count to ${originalCount}.`); updateBoosterCountDisplay(id, originalCount); } else { debugLog(`[handleResponse ${method}] Usage successful for ${name} (ID: ${id}). Count remains decremented.`); } if (success || cooldown || method === 'faction_traditional' || method === 'personal') { debugLog(`[handleResponse ${method}] Clearing boosterUseInProgress.`); sessionStorage.removeItem('boosterUseInProgress'); } else if (maybeClearProgress && (success || cooldown)) { debugLog(`[handleResponse ${method}] Clearing boosterUseInProgress (maybeClear=true).`); sessionStorage.removeItem('boosterUseInProgress'); } if (success || cooldown) { setTimeout(startCooldownChecks, 500); } }
    function extractCooldownMessage(html, type = 'Booster') { try { const tempDiv = document.createElement('div'); tempDiv.innerHTML = html; let msgElement = tempDiv.querySelector('.msg'); if (msgElement) return msgElement.textContent.trim(); let errorElement = tempDiv.querySelector('.error'); if (errorElement) return errorElement.textContent.trim(); return tempDiv.textContent.trim() || `You are on ${type.toLowerCase()} cooldown.`; } catch (e) { return `You are on ${type.toLowerCase()} cooldown.`; } }
    function showNotification(message, type = 'info') { document.querySelectorAll('.booster-notification').forEach(note => { const timerId = note.dataset.timerId; if (timerId) { clearInterval(parseInt(timerId)); } note.remove(); }); const n = document.createElement('div'); n.className = `booster-notification ${type}`; n.innerHTML = message; if (typeof message === 'string' && (message.toLowerCase().includes('cooldown') || message.includes('counter-wrap'))) { n.style.minWidth = '280px'; n.style.padding = '15px 25px'; } document.body.appendChild(n); let intervalId = null; const timerSpan = n.querySelector('.counter-wrap[data-time]'); if (timerSpan) { let remainingSeconds = parseInt(timerSpan.dataset.time); const updateTimer = () => { if (remainingSeconds <= 0) { timerSpan.textContent = "00:00:00"; if (intervalId) clearInterval(intervalId); return; } const hours = Math.floor(remainingSeconds / 3600); const minutes = Math.floor((remainingSeconds % 3600) / 60); const seconds = remainingSeconds % 60; const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; timerSpan.textContent = formattedTime; remainingSeconds--; }; updateTimer(); intervalId = setInterval(updateTimer, 1000); n.dataset.timerId = intervalId.toString(); debugLog(`[showNotification] Started timer ${intervalId} for notification.`); } n.style.transform = 'translate(-50%, -50%) scale(0.9)'; n.style.opacity = '0'; void n.offsetWidth; requestAnimationFrame(() => { n.style.transform = 'translate(-50%, -50%) scale(1)'; n.style.opacity = '1'; }); const dur = (type === 'error' || type === 'info') ? 7000 : 4000; const removalTimeoutId = setTimeout(() => { requestAnimationFrame(() => { n.style.opacity = '0'; n.style.transform = 'translate(-50%, -50%) scale(0.9)'; }); n.addEventListener('transitionend', () => { if (intervalId) { clearInterval(intervalId); debugLog(`[showNotification] Cleared timer ${intervalId} on notification removal.`); } n.remove(); }, { once: true }); }, dur); n.dataset.removalTimeoutId = removalTimeoutId.toString(); const tempDivLog = document.createElement('div'); tempDivLog.innerHTML = message; debugLog(`Notification [${type}]: ${(tempDivLog.textContent || tempDivLog.innerText || message).trim()}`); }
    function getNSTStyleToken() { try { const r = getRFC(); if (r) return r; } catch (e) {} return null; }
    function extractTokenFromPage() { try { if (typeof window.csrf !== 'undefined' && window.csrf && /^[a-f0-9]{16,}$/i.test(window.csrf)) return window.csrf; if (typeof window.csrf_token !== 'undefined' && window.csrf_token && /^[a-f0-9]{16,}$/i.test(window.csrf_token)) return window.csrf_token; if (typeof $ !== 'undefined' && typeof $.cookie === 'function') { const c = $.cookie('csrf'); if(c && /^[a-f0-9]{16,}$/i.test(c)) return c; } const inputs = document.querySelectorAll('input[name="csrf"], input[name="csrf_token"], input[id="csrf"], input[name="X-Csrf-Token"], input[data-csrf]'); for (const input of inputs) { const t = input.value || input.dataset?.csrf; if(t && /^[a-f0-9]{16,}$/i.test(t)) return t; } const patterns = [ /["']csrf["']\s*:\s*["']([a-f0-9]{16,})["']/, /csrf_token\s*=\s*["']([a-f0-9]{16,})["']/, /window\.csrf\s*=\s*["']([a-f0-9]{16,})["']/, /value=["']([a-f0-9]{16,})["']\s*name=["']csrf["']/ ]; const scripts = document.querySelectorAll('script:not([src])'); for (const script of scripts) { if (!script.textContent) continue; for (const p of patterns) { const m = script.textContent.match(p); if(m && m[1]) return m[1]; } } const meta = document.querySelector('meta[name="csrf-token"]'); if(meta && meta.content && /^[a-f0-9]{16,}$/i.test(meta.content)) return meta.content; } catch (e) {} debugLog('No CSRF token found in page'); return null; }
    function getPageCsrfToken() { return extractTokenFromPage(); }
    function getRFC() { if (typeof $ !== 'undefined' && typeof $.cookie === 'function') { const c = $.cookie('rfc_v'); if(c) return c; } try { const cs = document.cookie.split('; '); for (const c of cs) { const [n, v] = c.split('='); if(n === 'rfc_v') return v; } } catch (e) {} return null; }
    function hasBoosterCooldown() { const boosterCooldownElements = document.querySelectorAll('a[aria-label="Booster Cooldown"], [aria-label^="Booster Cooldown"]'); if (boosterCooldownElements.length > 0) { for(const el of boosterCooldownElements) { if (el.offsetParent !== null) { debugLog('Cooldown detected: Visible aria-label'); return true; } } } const statusIcons = document.querySelectorAll('.status-icons__wrap a, .status-icons li, .user-icons__wrap a, [class*="status-icon"], [class*="user-icon"]'); for (const icon of statusIcons) { if (icon.offsetParent === null) continue; const ariaLabel = icon.getAttribute('aria-label') || ''; const title = icon.getAttribute('title') || ''; const dataContent = icon.getAttribute('data-content') || ''; const iconText = icon.textContent || ''; if (ariaLabel.includes('Booster Cooldown') || title.includes('Booster Cooldown') || dataContent.includes('Booster Cooldown') || iconText.includes('Booster Cooldown')) { debugLog('Cooldown detected: Text/Attribute phrase match'); return true; } if (icon.className && typeof icon.className === 'string' && icon.className.includes('booster-cooldown')) { debugLog('Cooldown detected: Specific class name'); return true; } } return false; }
    function checkForPendingAlert() { try { const fromAlert = sessionStorage.getItem('fromBoosterAlert'); if (fromAlert) { sessionStorage.removeItem('fromBoosterAlert'); const isItemsPage = window.location.href.includes('torn.com/item.php'); const isFacArmouryPage = window.location.href.includes('factions.php') && window.location.hash.startsWith('#/tab=armoury'); const onCorrectPage = (isItemsPage && !useFactionBoosters) || (isFacArmouryPage && useFactionBoosters); if (onCorrectPage) { setTimeout(() => { if (!hasBoosterCooldown()) { if (!alertElements) alertElements = createAlert(); if (alertElements && alertElements.gui) alertElements.gui.style.display = 'block'; } }, 1500); } } const boosterProgress = sessionStorage.getItem('boosterUseInProgress'); if (boosterProgress) { try { const d = JSON.parse(boosterProgress); if (Date.now() - d.timestamp > 60000) sessionStorage.removeItem('boosterUseInProgress'); } catch(e) { sessionStorage.removeItem('boosterUseInProgress'); } } } catch (e) { debugLog('Error in checkForPendingAlert:', e); sessionStorage.removeItem('boosterUseInProgress'); sessionStorage.removeItem('fromBoosterAlert'); } }
    function startCooldownChecks() { if (cooldownCheckInterval) clearInterval(cooldownCheckInterval); if (cooldownObserver) cooldownObserver.disconnect(); const checkCooldownLogic = () => { const hasCooldown = hasBoosterCooldown(); const currentAlert = document.querySelector('.booster-alert'); if (!hasCooldown) { if (!currentAlert) { alertElements = createAlert(); debugLog('Created "No Boosters" alert'); checkForPendingAlert(); } } else if (currentAlert) { currentAlert.remove(); const mainGui = document.getElementById('boosterGui'); if (mainGui) mainGui.remove(); alertElements = null; debugLog('Removed "No Boosters" alert/GUI due to cooldown'); } }; setTimeout(checkCooldownLogic, 1500); cooldownObserver = new MutationObserver((mutations) => { const relevant = mutations.some(m => { const t = m.target; const nodes = [...Array.from(m.addedNodes), ...Array.from(m.removedNodes)]; const check = n => n.nodeType === 1 && ((n.className && typeof n.className === 'string' && (n.className.includes('status-icon') || n.className.includes('booster-cooldown'))) || (n.id && n.id.startsWith('icon')) || n.querySelector('[aria-label*="Cooldown"]')); return check(t) || nodes.some(check); }); if (relevant) { debugLog('Relevant DOM mutation for cooldown, re-checking.'); checkCooldownLogic(); } }); const target = document.querySelector('.status-icons__wrap, .user-icons__wrap, body'); if(target) cooldownObserver.observe(target, { childList: true, subtree: true, attributes: true, attributeFilter: ['class', 'aria-label', 'title', 'style'] }); cooldownCheckInterval = setInterval(checkCooldownLogic, 60000); console.log('%c Booster Alerts Cooldown Checks Started ', 'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px;'); }
    function setupForumMutationObserver() { if (!window.location.href.includes('torn.com/forums.php')) return; debugLog('Setting up forum mutation observer'); const forumContainer = document.getElementById('mainContainer') || document.body; const observer = new MutationObserver((mutations) => { const titleChanged = mutations.some(m => [...Array.from(m.addedNodes), ...Array.from(m.removedNodes)].some(n => n.nodeType === 1 && n.classList && n.classList.contains('content-title'))); if (titleChanged) { debugLog('Forum content title changed, re-evaluating alert placement'); setTimeout(startCooldownChecks, 750); } }); observer.observe(forumContainer, { childList: true, subtree: true, attributes: false }); debugLog('Forum mutation observer started'); }
    function checkPendingFactionBoosterUse() { const pendingUseData = sessionStorage.getItem('pendingFactionBoosterUse'); if (pendingUseData) { try { const pendingUse = JSON.parse(pendingUseData); const isFacArmouryPage = window.location.href.includes('factions.php') && window.location.hash.startsWith('#/tab=armoury'); if (isFacArmouryPage && pendingUse.id && pendingUse.name) { debugLog(`Processing pending faction booster use: ${pendingUse.name}`); sessionStorage.removeItem('pendingFactionBoosterUse'); const originalCount = pendingUse.originalCount !== undefined ? pendingUse.originalCount : 1; setTimeout(() => { useFactionBoosters = localStorage.getItem('useFactionBoosters') === 'true'; if (useFactionBoosters) { useBooster(pendingUse.id, pendingUse.name); } else { debugLog("Pending faction use detected, but user switched back to personal inventory. Aborting."); } }, 1500); } else if (!isFacArmouryPage) { debugLog('Still not on faction armoury page, keeping pending use data'); } else { debugLog('Clearing invalid pending faction booster use data'); sessionStorage.removeItem('pendingFactionBoosterUse'); } } catch (e) { debugLog('Error processing pending faction booster use:', e); sessionStorage.removeItem('pendingFactionBoosterUse'); } } }
    // --- End Core Logic ---

    // --- Item List/Navigation Handlers (Unchanged) ---
    function observeItemListContainerOnce(targetContainer, itemSelector) { if (itemListObserver) { itemListObserver.disconnect(); debugLog('[observeItemListOnce] Disconnected previous item list observer.'); } const handleMutations = (mutations, observer) => { const itemsAdded = mutations.some(mutation => Array.from(mutation.addedNodes).some(node => node.nodeType === 1 && (node.matches(itemSelector) || node.querySelector(itemSelector)))); if (itemsAdded) { debugLog('[observeItemListOnce] Detected initial item nodes added. Fetching counts and building panel.'); observer.disconnect(); debugLog('[observeItemListOnce] Disconnected item list observer after initial detection.'); itemListObserver = null; fetchInitialBoosterCounts(useFactionBoosters, targetContainer); buildOrRebuildQuickUsePanel(); panelBuilt = true; } }; itemListObserver = new MutationObserver(handleMutations); try { itemListObserver.observe(targetContainer, { childList: true, subtree: true }); debugLog('[observeItemListOnce] Initial item list observer attached to:', targetContainer); setTimeout(() => { if (!panelBuilt && targetContainer.querySelector(itemSelector)) { debugLog('[observeItemListOnce] Items already present on initial check. Fetching counts.'); if (itemListObserver) itemListObserver.disconnect(); itemListObserver = null; fetchInitialBoosterCounts(useFactionBoosters, targetContainer); buildOrRebuildQuickUsePanel(); panelBuilt = true; } else if (!panelBuilt) { debugLog('[observeItemListOnce] Items not present on initial check. Waiting for observer...'); } }, 100); } catch (e) { console.error("BoosterAlerts: Failed to observe item list container:", targetContainer, e); } }
    function handleDelayedScan() { debugLog(`[handleDelayedScan] Running delayed scan.`); const containerSelector = useFactionBoosters ? '#faction-armoury .armoury-list-wrap, #armoury-boosters ul.item-list, #armoury-medical ul.item-list, #armoury-drugs ul.item-list, #armoury-temporary ul.item-list' : 'div#category-wrap > ul.ui-tabs-panel:not([aria-hidden="true"])'; const targetContainer = document.querySelector(containerSelector); fetchInitialBoosterCounts(useFactionBoosters, targetContainer || document); buildOrRebuildQuickUsePanel(); }
    function handleItemTabClick(event) { const tabLink = event.target.closest('div[class*="items-cont"] ul[role="tablist"] a[href^="#"]'); if (!tabLink) return; if (!window.location.href.includes('item.php') || useFactionBoosters) return; debugLog(`[handleItemTabClick] Click detected on item tab link: ${tabLink.href}`); const targetHash = tabLink.hash; setTimeout(() => { debugLog(`[handleItemTabClick] location.hash after click event: ${location.hash}`); }, 0); debugLog(`[handleItemTabClick] Scheduling delayed scan with hardcoded delay ${TAB_SWITCH_RESCAN_DELAY}.`); clearTimeout(window.boosterAlertDelayedScanTimeout); window.boosterAlertDelayedScanTimeout = setTimeout(handleDelayedScan, TAB_SWITCH_RESCAN_DELAY); }
    function logHashChange() { debugLog(`[HashChangeLogger] hashchange event detected! New hash: ${location.hash}`); initialize(); }
    // --- End Item List/Navigation Handlers ---

    // --- Initialization (Uses localStorage via helpers) ---
    function initialize() {
        console.log(`%c Booster Alerts v${SCRIPT_VERSION} Initializing (Persistent Counts) (isInitialLoad: ${isInitialLoad})`, 'background: #2196F3; color: white; padding: 2px 5px; border-radius: 3px;');
        if(DEBUG_MODE) debugLog('Using DEBUG_MODE');
        const wasInitialLoad = isInitialLoad; isInitialLoad = false;
        useFactionBoosters = localStorage.getItem('useFactionBoosters') === 'true'; panelBuilt = false;
        if (coopObserver) coopObserver.disconnect(); if (itemListObserver) itemListObserver.disconnect(); if (navigationObserver) navigationObserver.disconnect(); if (cooldownObserver) cooldownObserver.disconnect(); if (waitForContainerObserver) waitForContainerObserver.disconnect();
        if (coopAdjustInterval) clearInterval(coopAdjustInterval); if (cooldownCheckInterval) clearInterval(cooldownCheckInterval); clearTimeout(window.boosterAlertPanelRebuildTimeout); clearTimeout(window.boosterAlertDelayedScanTimeout); clearTimeout(waitForContainerTimeout);
        checkPendingFactionBoosterUse(); startCooldownChecks(); setupForumMutationObserver(); setupCooperativePositioning();

        const isItemsPage = window.location.href.includes('item.php'); const isFactionArmouryPage = window.location.href.includes('factions.php') && window.location.hash.startsWith('#/tab=armoury'); const isRelevantPage = (isItemsPage && !useFactionBoosters) || (isFactionArmouryPage && useFactionBoosters);
        debugLog(`[initialize] State Check: isItemsPage=${isItemsPage}, isFactionArmouryPage=${isFactionArmouryPage}, useFactionBoosters=${useFactionBoosters}, isRelevantPage=${isRelevantPage}`);

        if (isRelevantPage) {
            debugLog("[initialize] Relevant page detected. Proceeding with observer logic.");
            const containerSelector = useFactionBoosters ? '#faction-armoury .armoury-list-wrap, #armoury-boosters ul.item-list, #armoury-medical ul.item-list, #armoury-drugs ul.item-list, #armoury-temporary ul.item-list' : '#category-wrap';
            const itemSelector = useFactionBoosters ? '#faction-armoury ul.item-list > li, #armoury-boosters ul.item-list > li, #armoury-medical ul.item-list > li, #armoury-drugs ul.item-list > li, #armoury-temporary ul.item-list > li' : 'li[data-item]';
            const parentSelector = 'body';
            if (wasInitialLoad) {
                debugLog("[initialize] Initial load: Waiting for container via observer.");
                const parentContainer = document.querySelector(parentSelector);
                if (!parentContainer) { console.error(`[initialize] Initial load: Could not find parent container ('${parentSelector}')!`); setTimeout(() => { debugLog("[initialize] Initial load: Fallback build after parent container not found."); fetchInitialBoosterCounts(useFactionBoosters, document); buildOrRebuildQuickUsePanel(); panelBuilt = true; }, 3000); }
                else { let targetContainer = parentContainer.querySelector(containerSelector); if (targetContainer) { debugLog(`[initialize] Initial load: Container '${containerSelector}' already exists. Observing for items.`); observeItemListContainerOnce(targetContainer, itemSelector); } else { debugLog(`[initialize] Initial load: Container '${containerSelector}' not found. Observing parent '${parentSelector}'.`); clearTimeout(waitForContainerTimeout); waitForContainerObserver = new MutationObserver((mutations, observer) => { let foundContainer = null; for (const mutation of mutations) { for (const node of mutation.addedNodes) { if (node.nodeType === 1) { if (node.matches(containerSelector)) { foundContainer = node; } else if (typeof node.querySelector === 'function') { foundContainer = node.querySelector(containerSelector); } if (foundContainer) { debugLog(`[initialize] Initial load: Container '${containerSelector}' detected via observer.`); clearTimeout(waitForContainerTimeout); observer.disconnect(); waitForContainerObserver = null; observeItemListContainerOnce(foundContainer, itemSelector); return; } } } } }); waitForContainerObserver.observe(parentContainer, { childList: true, subtree: true }); waitForContainerTimeout = setTimeout(() => { if (waitForContainerObserver) { console.warn(`[initialize] Initial load: Timeout (${CONTAINER_WAIT_TIMEOUT}ms) waiting for container '${containerSelector}' via observer. Attempting direct build.`); waitForContainerObserver.disconnect(); waitForContainerObserver = null; fetchInitialBoosterCounts(useFactionBoosters, document); buildOrRebuildQuickUsePanel(); panelBuilt = true; } }, CONTAINER_WAIT_TIMEOUT); } }
            } else { debugLog(`[initialize] Navigation/HashChange detected. Scheduling delayed scan.`); clearTimeout(window.boosterAlertDelayedScanTimeout); window.boosterAlertDelayedScanTimeout = setTimeout(handleDelayedScan, TAB_SWITCH_RESCAN_DELAY); }
        } else { debugLog("[initialize] Not on relevant item/armoury page or wrong mode. Fetching stored counts and attempting panel build."); fetchInitialBoosterCounts(useFactionBoosters, document); buildOrRebuildQuickUsePanel(); panelBuilt = true; }

        // Setup Navigation Listeners
        let lastHref = location.href; try { navigationObserver = new MutationObserver(() => { if (location.href !== lastHref) { lastHref = location.href; debugLog("URL changed (MutationObserver), re-initializing."); isInitialLoad = true; initialize(); } }); navigationObserver.observe(document.body, { childList: true, subtree: true }); } catch (e) { console.error("BoosterAlerts: Failed to observe body for URL changes:", e); }
        window.addEventListener('hashchange', logHashChange); document.body.addEventListener('click', handleItemTabClick, true);
        debugLog("[initialize] Added navigation listeners (MutationObserver, hashchange logger, click listener).");
    }

    // --- Script Entry Point ---
    function runInitialization() { console.log('[BoosterAlert Script] DOM ready, running initialization.'); isInitialLoad = true; initialize(); }
    try { setTimeout(() => { if (document.readyState === 'complete' || document.readyState === 'interactive') { runInitialization(); } else { window.addEventListener('DOMContentLoaded', runInitialization, { once: true }); } }, 250); }
    catch (e) { console.error("BoosterAlerts: Critical error during initial setup:", e); }

})();